1
00:00:26,300 --> 00:00:28,683
这里我们创建一个 process_input 函数

2
00:00:31,866 --> 00:00:34,333
我们把处理输入的代码都写在这里面

3
00:00:35,500 --> 00:00:39,550
这里我们检查用户是否按下了键盘左上角的 ESC 键

4
00:00:40,716 --> 00:00:43,500
我们向 glfw.get_key 传入 glfw.KEY_ESCAPE

5
00:00:45,300 --> 00:00:47,233
表示想检查这个按键的状态

6
00:01:01,050 --> 00:01:01,866
条件成立

7
00:01:01,883 --> 00:01:05,116
那么就通过 glfw.set_window_should_close 函数

8
00:01:06,450 --> 00:01:08,683
来把这个窗口标记为需要关闭

9
00:01:09,000 --> 00:01:11,766
那么对于底下的这个渲染循环而言

10
00:01:12,383 --> 00:01:14,783
下一次的循环条件检测就会失败

11
00:01:14,783 --> 00:01:16,766
退出这个循环使得程序结束

12
00:01:17,350 --> 00:01:20,100
我们在渲染循环中调用 process_input

13
00:01:20,966 --> 00:01:25,266
这就给我们一个非常简单的方式来检测特定的键是否被按下

14
00:01:25,800 --> 00:01:27,733
并在每一帧做出处理

15
00:01:29,683 --> 00:01:32,316
现在我们可以开始进行画面渲染了

16
00:01:33,716 --> 00:01:36,966
我们把渲染操作的代码插到循环的这里

17
00:01:37,750 --> 00:01:42,050
因为我们想让这些渲染指令在每次渲染都能被执行

18
00:01:42,816 --> 00:01:45,100
为了测试一切都正常工作

19
00:01:45,100 --> 00:01:47,733
我们使用一个自定义的颜色清空屏幕

20
00:01:48,466 --> 00:01:52,200
在每个新的渲染迭代开始的时候我们总是希望清屏

21
00:01:52,650 --> 00:01:55,300
否则我们仍会看见上一次的渲染结果
（这可能是你想要的效果，但通常来说不是）

22
00:01:56,033 --> 00:02:00,083
我们可以使用 ctx.clear 来清空屏幕的颜色缓冲

23
00:02:21,566 --> 00:02:22,750
运行程序

24
00:02:23,083 --> 00:02:26,916
可以看到我们将屏幕设置为了类似黑板的深蓝绿色

25
00:02:29,350 --> 00:02:32,600
你可以在简介的链接中找到这部分的完整源代码

26
00:02:34,216 --> 00:02:37,200
在这两节中，我们创建了基本的窗口

27
00:02:37,600 --> 00:02:39,900
了解了如何处理用户按键输入

28
00:02:40,350 --> 00:02:42,433
并调整了窗口的填充颜色

29
00:02:43,283 --> 00:02:47,233
在下一节，我们会向这个窗口上绘制更为具体的东西

