1
00:01:24,550 --> 00:01:28,833
首先，请确保你安装的是 3.7 或更高版本的 Python

2
00:01:29,266 --> 00:01:31,550
如果不是的话，你可以尝试以下方式：

3
00:01:33,183 --> 00:01:35,483
我使用的编辑器是 vscode

4
00:01:36,016 --> 00:01:38,983
这里我在终端输入 python --version

5
00:01:39,283 --> 00:01:41,350
检查当前使用的 Python 版本

6
00:01:41,616 --> 00:01:45,699
显示 Python 3.12，是 3.7 及以上的，没有问题

7
00:01:47,066 --> 00:01:48,816
如果你用了 anaconda 之类的工具

8
00:01:48,816 --> 00:01:50,733
可能得切换一下虚拟环境

9
00:01:51,566 --> 00:01:53,416
接着，我们使用 pip 来安装

10
00:01:53,416 --> 00:01:55,566
moderngl 和 GLFW

11
00:01:56,850 --> 00:02:01,850
因为我这里使用镜像，所以说我在后面加上了清华镜像源的链接

12
00:02:06,116 --> 00:02:11,116
安装好 moderngl 和 GLFW 后，我们就可以正式开始编写代码

13
00:02:12,050 --> 00:02:14,483
新建一个 .py Python 文件

14
00:02:15,883 --> 00:02:19,549
我们先把 moderngl 和 GLFW 导入一下

15
00:02:23,050 --> 00:02:28,916
因为我感觉 moderngl 有点太长了，所以我用 `as` 给它起了“mgl”的简写

16
00:02:30,100 --> 00:02:34,016
glfw 不是一上来就能用的，我们要先初始化一下

17
00:02:39,766 --> 00:02:44,050
在正常情况下，glfw.init() 成功初始化后会返回 True

18
00:02:44,050 --> 00:02:46,000
所以我们加上一个 not 取反

19
00:02:46,000 --> 00:02:50,450
来表示当 glfw 初始化失败时，抛出“GLFW出错”的报错

20
00:02:51,000 --> 00:02:53,416
接下来我们创建一个窗口对象

21
00:03:01,100 --> 00:03:04,366
这个窗口对象存放了所有和窗口相关的数据

22
00:03:04,366 --> 00:03:07,566
而且会被GLFW的其他函数频繁地用到

23
00:03:08,333 --> 00:03:11,516
这里当然我们也要检查一下是否成功创建了窗口

24
00:03:16,833 --> 00:03:22,333
在这里，create_window 函数需要窗口的宽和高作为它的前两个参数

25
00:03:22,333 --> 00:03:27,316
第三个参数表示这个窗口的标题，这里我们使用"LearnOpenGL"

26
00:03:27,383 --> 00:03:30,000
当然你也可以使用你喜欢的名称

27
00:03:30,333 --> 00:03:32,350
最后两个参数我们暂时忽略

28
00:03:35,000 --> 00:03:41,866
创建完窗口我们就可以通知 GLFW 将我们窗口的上下文设置为当前线程的主上下文了

29
00:03:43,600 --> 00:03:50,433
并且我们可以使用 ctx = mgl.create_context() 得到这个上下文对象

30
00:03:51,050 --> 00:03:53,983
我们就可以通过它控制窗口上的画面

31
00:04:48,516 --> 00:04:53,516
一般而言，当用户改变窗口的大小的时候，视口也应该被调整

32
00:04:53,800 --> 00:04:56,200
我们可以对窗口注册一个回调函数（Callback Function）

33
00:04:56,466 --> 00:04:59,500
它会在每次窗口大小被调整的时候被调用

34
00:05:00,250 --> 00:05:02,583
具体来说，我们先写一个函数

35
00:05:09,466 --> 00:05:13,616
这个函数接受三个参数，这是 GLFW 约定好的

36
00:05:13,966 --> 00:05:19,349
第一个是 window，表示是哪个窗口的大小改变了，这里我们用不到

37
00:05:19,633 --> 00:05:23,416
width 和 height 这两个整数表示窗口新的大小

38
00:05:25,633 --> 00:05:27,383
我们注册这个函数

39
00:05:27,966 --> 00:05:29,383
告诉GLFW

40
00:05:29,383 --> 00:05:34,049
我们希望每当窗口大小改变的时候就调用一下这个函数

41
00:05:34,516 --> 00:05:36,566
{\an5}（注：当窗口第一次显示的时候，这个函数也会被调用）

42
00:05:37,133 --> 00:05:39,566
我们可不希望只绘制一个图像之后

43
00:05:39,566 --> 00:05:42,783
我们的应用程序就立即退出并关闭窗口

44
00:05:42,966 --> 00:05:49,200
我们希望程序在我们主动关闭它之前不断绘制图像并能够接受用户输入

45
00:05:49,466 --> 00:05:52,933
因此，我们需要在程序中添加一个 while 循环

46
00:05:52,933 --> 00:05:55,283
我们可以把它称之为渲染循环（Render Loop）

47
00:05:55,666 --> 00:05:59,050
它能在我们点击关闭按钮之前一直保持运行

48
00:05:59,666 --> 00:06:02,716
我们用几行代码实现一个简单的渲染循环

49
00:06:09,416 --> 00:06:11,616
其中 glfw.window_should_close 函数

50
00:06:11,616 --> 00:06:19,450
在我们每次循环的开始前检查一次 GLFW 是否被要求退出（例如按了关闭键之后）

51
00:06:20,016 --> 00:06:25,016
如果是的话，该函数返回 True，这个渲染循环将停止运行

52
00:06:25,550 --> 00:06:28,950
glfw.poll_events 函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）

53
00:06:29,283 --> 00:06:32,916
更新窗口状态，并调用对应的回调函数进行处理

54
00:06:33,383 --> 00:06:37,866
比如我们在前面就注册了一个响应窗口大小改变的回调函数

55
00:06:38,783 --> 00:06:44,616
glfw.swap_buffers 函数会交换颜色缓冲，也就是更新窗口上显示的内容

56
00:06:45,983 --> 00:06:48,550
当窗口关闭，渲染循环结束后

57
00:06:48,816 --> 00:06:52,483
我们需要正确释放/删除之前分配的所有资源

58
00:06:54,066 --> 00:06:58,250
我们可以在最后调用 glfw.terminate 函数来完成

59
00:06:59,233 --> 00:07:02,250
这样便能清理所有的资源并正确地退出应用程序

60
00:07:03,283 --> 00:07:05,583
现在你可以尝试运行这个程序了

61
00:07:07,433 --> 00:07:11,300
如果没有做错的话，那么就会出现一个非常无聊的黑色窗口

62
00:07:12,166 --> 00:07:15,216
如果没有出现，或者你想要我编写好的这些代码

63
00:07:15,483 --> 00:07:17,683
请在简介中点开这一节的代码

